import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

def rk4_step(y0, x0, f, h, f_args = {}):
    ''' Simple python implementation for one RK4 step. 
        Inputs:
            y_0    - M x 1 numpy array specifying all variables of the ODE at the current time step
            x_0    - current time step
            f      - function that calculates the derivates of all variables of the ODE
            h      - time step size
            f_args - Dictionary of additional arguments to be passed to the function f
        Output:
            yp1 - M x 1 numpy array of variables at time step x0 + h
            xp1 - time step x0+h
    '''
    k1 = h * f(y0, x0, **f_args)
    k2 = h * f(y0 + k1/2., x0 + h/2., **f_args)
    k3 = h * f(y0 + k2/2., x0 + h/2., **f_args)
    k4 = h * f(y0 + k3, x0 + h, **f_args)
    
    xp1 = x0 + h
    yp1 = y0 + 1./6.*(k1 + 2.*k2 + 2.*k3 + k4)
    
    return(yp1,xp1)

def rk4(y0, x0, f, h, n, f_args = {}):
    ''' Simple implementation of RK4
        Inputs:
            y_0    - M x 1 numpy array specifying all variables of the ODE at the current time step
            x_0    - current time step
            f      - function that calculates the derivates of all variables of the ODE
            h      - time step size
            n      - number of steps
            f_args - Dictionary of additional arguments to be passed to the function f
        Output:
            yn - N+1 x M numpy array with the results of the integration for every time step (includes y0)
            xn - N+1 x 1 numpy array with the time step value (includes start x0)
    '''
    yn = np.zeros((n+1, y0.shape[0]))
    xn = np.zeros(n+1)
    yn[0,:] = y0
    xn[0] = x0
    
    for n in np.arange(1,n+1,1):
        yn[n,:], xn[n] = rk4_step(y0 = yn[n-1,:], x0 = xn[n-1], f = f, h = h, f_args = f_args)
        
    return(yn, xn)

def three_body_problem(y,x,m1,m2,m3):
    ''' twelve coupled ordinary differential equations of first order
        (converted into the standard form) '''
    mu = 3
    yn = np.ones(12)
    G=1
    x1 = y[0];  y1 = y[1]
    x2 = y[4];  y2 = y[5]
    x3 = y[8];  y3 = y[9]

    r12 = np.sqrt((x1-x2)**2+(y1-y2)**2) # distance between body 1 and body 2
    r13 = np.sqrt((x1-x3)**2+(y1-y3)**2) # distance between body 1 and body 3
    r23 = np.sqrt((x2-x3)**2+(y2-y3)**2) # distance between body 2 and body 3

    yn[0] = y[2]   # differential equations for body 1
    yn[1] = y[3]
    yn[2] = (-m2*G/r12**3)*(x1-x2)+(-m3*G/r13**3)*(x1-x3) 
    yn[3] = (-m2*G/r12**3)*(y1-y2)+(-m3*G/r13**3)*(y1-y3) 

    yn[4] = y[6]    # differential equations for body 2
    yn[5] = y[7] 
    yn[6] = (-m1*G/r12**3)*(x2-x1)+(-m3*G/r23**3)*(x2-x3) 
    yn[7] = (-m1*G/r12**3)*(y2-y1)+(-m3*G/r23**3)*(y2-y3) 

    yn[8] = y[10]  # differential equations for body 3
    yn[9] = y[11] 
    yn[10] = (-m1*G/r13**3)*(x3-x1)+(-m2*G/r23**3)*(x3-x2) 
    yn[11] = (-m1*G/r13**3)*(y3-y1)+(-m2*G/r23**3)*(y3-y2) 

    return yn
    
    
class Body:
    def __init__(self,mass,position,velocity=np.array([0.,0.])):
        self.mass = mass            # mass of the body
        self.position = position    # inital position vector
        self.velocity = velocity    # inital velocity vector

def initial_conditions(body1,body2,body3):
    ''' Function to write the inital conditions into an numpy array '''
    return np.array([body1.position[0],body1.position[1],
                     body1.velocity[0],body1.velocity[1],
                     body2.position[0],body2.position[1],
                     body2.velocity[0],body2.velocity[1],
                     body3.position[0],body3.position[1],
                     body3.velocity[0],body3.velocity[1]])


G = 1.  # simplify the system by setting the gravitational constant to G=1
# create the three bodies with their initial conditions

def setConditions(n):
    if(n==1):
        body1 = Body(1., np.array([-0.97000436,0.24308753]), np.array([-0.46620368,-0.43236573]))
        body2 = Body(1., np.array([0.97000436,-0.24308753]), np.array([-0.46620368,-0.43236573]))
        body3 = Body(1., np.array([0.,0.]), np.array([0.93240737,0.86473146]))
    elif(n==2):
        body1 = Body(1., np.array([0,0]), np.array([0,1]))
        body2 = Body(1., np.array([1,0]), np.array([0,0]))
        body3 = Body(1., np.array([-1,0]), np.array([0,-1]))
    elif(n==3):
        body1 = Body(3., np.array([3.,-1.]))
        body2 = Body(4., np.array([-1.,2.]))
        body3 = Body(5., np.array([-1.,-1.]))
    elif(n==4):
        body1 = Body(3., np.array([3.,-1.]))
        body2 = Body(4., np.array([-1.,2.]))
        body3 = Body(5., np.array([-1.,-1.]),np.array([0.1,0]))
    elif(n>=5):
        if(n==5):
            a = 0.9
            b = -0.9
            c = 0
            d = 3
        elif(n==6):
            a = 0.6
            b = -0.9
            c = 1
            d = 0
        elif(n==7):
            a = 0
            b = 3
            c = 1
            d = 0
        elif(n==8):
            a = 0
            b = 2.405
            c = 1
            d = 0
        body1 = Body(10., np.array([c,d]),np.array([a,b]))
        body2 = Body(10., np.array([c*np.cos(2*np.pi/3)-d*np.sin(2*np.pi/3),c*np.sin(2*np.pi/3)+d*np.cos(2*np.pi/3)]),np.array([a*np.cos(2*np.pi/3)-b*np.sin(2*np.pi/3),a*np.sin(2*np.pi/3)+b*np.cos(2*np.pi/3)]))
        body3 = Body(10., np.array([c*np.cos(-2*np.pi/3)-d*np.sin(-2*np.pi/3),c*np.sin(-2*np.pi/3)+d*np.cos(-2*np.pi/3)]), np.array([a*np.cos(-2*np.pi/3)-b*np.sin(-2*np.pi/3),a*np.sin(-2*np.pi/3)+b*np.cos(-2*np.pi/3)]))

    return body1, body2, body3

# def setConditions(n):
#     body1Choice = np.array([Body(1., np.array([-0.97000436,0.24308753]), np.array([-0.46620368,-0.43236573])),
#                             Body(1., np.array([0,0]), np.array([0,1])),
#                             Body(3., np.array([3.,-1.]))])
#     body2Choice = np.array([Body(1., np.array([0.97000436,-0.24308753]), np.array([-0.46620368,-0.43236573])),
#                             Body(1., np.array([1,0]), np.array([0,0])),
#                             Body(4., np.array([-1.,2.]))])
#     body3Choice = np.array([Body(1., np.array([0.,0.]), np.array([0.93240737,0.86473146])),
#                             Body(1., np.array([-1,0]), np.array([0,-1])),
#                             Body(5., np.array([-1.,-1.]))])
#     return body1Choice[n], body2Choice[n], body3Choice[n]

body1, body2, body3 = setConditions(8)
N = 10000



yn, xn = rk4(initial_conditions(body1,body2,body3),0,three_body_problem, 0.001, N, {'m1':body1.mass,'m2':body2.mass,'m3':body3.mass})

fig, ax = plt.subplots()


# def countEncounters():
#     for i in range(N+1):
#         r1 = np.sqrt(yn[i,0]**2+yn[i,1]**2)
#         r2 = np.sqrt(yn[i,4]**2+yn[i,5]**2)
#         r3 = np.sqrt(yn[i,8]**2+yn[i,9]**2)
#         r12 = r1-r2
#         if()


def trajectories(i):
    ax.clear()
    ax.set_title('Numerical Simulation of the Gravitational Three-Body Problem')
    ax.set_xlabel(r'$x$-coordinates'); ax.set_ylabel(r'$y$-coordinates')
    
    step = 40
    ax.plot(yn[:step*i,0],yn[:step*i,1],'gray')
    ax.plot(yn[:step*i,4],yn[:step*i,5],'gray')
    ax.plot(yn[:step*i,8],yn[:step*i,9],'gray')

    ax.plot(yn[step*i-1:step*i,0], yn[step*i-1:step*i,1], 'b.', label='Body 1')
    ax.plot(yn[step*i-1:step*i,4], yn[step*i-1:step*i,5], 'r.', label='Body 2')
    ax.plot(yn[step*i-1:step*i,8], yn[step*i-1:step*i,9], 'g.', label='Body 3')

    

    ax.legend(loc='upper right'); ax.axis('equal')



animate = animation.FuncAnimation(fig, trajectories, interval=10)
plt.show()

# ax.quiver(yn[0,0],yn[0,1],yn[0,2],yn[0,3],units='xy' ,scale=1)
#     ax.quiver(yn[0,4],yn[0,5],yn[0,6],yn[0,7],units='xy' ,scale=1)
#     ax.quiver(yn[0,8],yn[0,9],yn[0,10],yn[0,11],units='xy' ,scale=1)
#     ax.plot(yn[0,0],yn[0,1],'b.')
#     ax.plot(yn[0,4],yn[0,5],'r.')
#     ax.plot(yn[0,8],yn[0,9],'g.')