import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# def gausselimination(matrix,solution)
#     m11 = matrix[0][0]
#     m12 = matrix[0][1]
#     m21 = matrix[1][0]
#     m22 = matrix[1][1]
#     f1 = solution[0]
#     f2 = solution[1]

#     y = (f1m21-m11f2)(m12m21-m11m22)
#     x = (f1-m12y)m11
#     return x,y

def setMatrix(a,b,c)
    N = len(b)
    matrix = np.zeros(shape=(N,N))
    for i in range(N)
        matrix[i][i] = b[i]
    for i in range(1,N)
        matrix[i][i-1] = a[i-1]
        matrix[i-1][i] = c[i-1]
    return matrix
    

def gaussjordan(matrix,solution)
    matrix, solution = getTriangular(matrix,solution)
    solution = getSolutionfromGaussJordan(matrix,solution)
    return solution


def getTriangular(matrix,solution)
    N = len(matrix[0])
    for i in range(N)
        solution[i] = solution[i]matrix[i][i]
        matrix[i] = matrix[i]matrix[i][i]
        for j in range(i+1,N)
            solution[j] = solution[j]-solution[i]matrix[j][i]
            matrix[j] = matrix[j] - matrix[i]matrix[j][i]
    return matrix,solution

def getSolutionfromGaussJordan(matrix,solution)
    N = len(matrix[0])
    for i in range(N)
        for j in range(i+1,N)
            solution[N-j-1] = solution[N-j-1] - solution[N-i-1]matrix[N-j-1][N-i-1]
            matrix[N-j-1] = matrix[N-j-1]-matrix[N-i-1]matrix[N-j-1][N-i-1]
    return solution

def BackwardSubstitution(matrix,y)
    N = len(matrix[0])
    x = np.ones(N)
    x[N-1] = y[N-1]
    for i in range(2,N)
        x[N-i] = y[N-i]-np.dot(matrix[N-i],x)+1
    return x

def checksolution(x,matrix,y)
    s = np.dot(matrix,x)
    diff = s-y
    return diff

def solvingSubroutine(a,b,c,y)
    matrix = setMatrix(a,b,c)
    solution = gaussjordan(matrix,y)
    
    return solution

# print(setMatrix([1,2,4,2,4],[3,4,5,8,3,2],[6,7,4,2,56]))

# def checksolution(x,matrix,solution)
#     s1 = matrix[0][0]x[0]+matrix[0][1]x[1]
#     s2 = matrix[1][0]x[0]+matrix[1][1]x[1]
#     diff1 = s1-solution[0]
#     diff2 = s2-solution[1]
#     return diff1,diff2

# def testForPrecisionProblem()
#     for i in range(6,330)
#         epsilon = 10(-i)
#         matrix = np.array([[epsilon,0.5],[0.5,0.25]])
#         solution = np.array([12,14])
#         x  = gaussjordan(matrix,solution)
#         diff = checksolution(x,matrix,solution)
#         if(diff[0] != 0 and diff[1] != 0)
#             print(precision problem! Epsilon ! 10^-+str(i))
#             break
    
# matrix = np.array([[3,0.5],[0.5,0.25]])
# solution = np.array([12,14])
matrix = np.array([[1,1,1],[2,3,7],[1,3,-2]])
solution= np.array([3,0,17])

#answer = gaussjordan(matrix,solution)
print(matrix,solution)
matrix, solution = getTriangular(matrix,solution)
print(matrix,solution)
answer = BackwardSubstitution(matrix,solution)
print(answer)
#print(answer)

# a = np.linalg.solve(matrix,solution)
# print(a)
# print(np.dot(matrix,a))

# print(np.eye(3,k=0))




### Aufgaben 3.4.5
# N = 10
# a = np.ones(N-1)-1
# b = np.ones(N)3
# c = np.ones(N-1)-1
# y = np.ones(N)0.2

# x = solvingSubroutine(a,b,c,y)
# print(x)

# diff = checksolution(x,setMatrix(a,b,c),np.ones(N)0.2)
# print(np.dot(x,setMatrix(a,b,c)))
# print(diff)