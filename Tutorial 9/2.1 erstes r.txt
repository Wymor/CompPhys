import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.optimize import fsolve

def P(lam,o,r,b):
    return lam**3 +(1+b+o)*lam**2 + b*(o+r)*lam + 2*o*b*(r-1)

def rk4_step(y0, x0, f, h, f_args = {}):
    ''' Simple python implementation for one RK4 step. 
        Inputs:
            y_0    - M x 1 numpy array specifying all variables of the ODE at the current time step
            x_0    - current time step
            f      - function that calculates the derivates of all variables of the ODE
            h      - time step size
            f_args - Dictionary of additional arguments to be passed to the function f
        Output:
            yp1 - M x 1 numpy array of variables at time step x0 + h
            xp1 - time step x0+h
    '''
    k1 = h * f(y0, x0, **f_args)
    k2 = h * f(y0 + k1/2., x0 + h/2., **f_args)
    k3 = h * f(y0 + k2/2., x0 + h/2., **f_args)
    k4 = h * f(y0 + k3, x0 + h, **f_args)
    
    xp1 = x0 + h
    yp1 = y0 + 1./6.*(k1 + 2.*k2 + 2.*k3 + k4)
    
    return(yp1,xp1)

def rk4(y0, x0, f, h, n, f_args = {}):
    ''' Simple implementation of RK4
        Inputs:
            y_0    - M x 1 numpy array specifying all variables of the ODE at the current time step
            x_0    - current time step
            f      - function that calculates the derivates of all variables of the ODE
            h      - time step size
            n      - number of steps
            f_args - Dictionary of additional arguments to be passed to the function f
        Output:
            yn - N+1 x M numpy array with the results of the integration for every time step (includes y0)
            xn - N+1 x 1 numpy array with the time step value (includes start x0)
    '''
    yn = np.zeros((n+1, y0.shape[0]))
    xn = np.zeros(n+1)
    yn[0,:] = y0
    xn[0] = x0
    
    for n in np.arange(1,n+1,1):
        yn[n,:], xn[n] = rk4_step(y0 = yn[n-1,:], x0 = xn[n-1], f = f, h = h, f_args = f_args)
        
    return(yn, xn)

def Lorenzattractor(y,x,r,o,b):
    yn = np.ones(3)
    x1 = y[0]
    y1 = y[1]
    z1 = y[2]
    yn[0] = -o*(x1-y1)
    yn[1] = r*x1 - y1 - x1*z1
    yn[2] = x1*y1 - b*z1
    return yn

def initial_conditions(r,o,b,delta):
    if (r < 1):
        init = np.array([0,0,0]) + np.array([delta,delta,delta])
    elif (r > 1):
        a0 = np.sqrt(b*(r-1))
        init_plus = np.array([a0,a0,r-1])
        init_minus = np.array([-a0,-a0,r-1])

    return init_plus

r = 1.17
o = 10
b = 8/3
delta = 0.1

yn ,xn = rk4(initial_conditions(r,o,b,delta),0,Lorenzattractor,4e-4,int(5*1e3),{'r':0.5,'o':10,'b':8/3})

X = yn[:,0]
Y = yn[:,1]
#X, Y = np.meshgrid(X, Y)
Z = yn[:,2]

from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter

fig = plt.figure(figsize=(6,6))
ax = fig.add_subplot(111, projection='3d')

ax.scatter(X, Y, Z)
#fig.colorbar(surf, shrink=0.5, aspect=5)

plt.show()